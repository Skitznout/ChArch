#!/usr/bin/env bash
# Written by Draco (tytydraco) @ GitHub

# Add busybox components from Magisk
[[ -d "/sbin/.magisk/busybox" ]] && [[ "$PATH" != *"/sbin/.magisk/busybox"* ]] &&
	export PATH="/sbin/.magisk/busybox:$PATH"

err() {
	echo -e "\e[91m[!] $@\e[39m"
	exit 1
}

# Check for required dependencies
for dep in chroot curl env find id mkdir mount mountpoint readlink rm sed tar unarch wc
do
	! command -v "$dep" &> /dev/null && err "Unable to locate dependency $dep. Exiting."
done

# Check for root permissions
[[ `id -u` -ne 0 ]] && err "No root permissions. Exiting."

# Path containing rootfs tarball and all rootfs instances
if [[ -d "/data" ]]
then
	CHROOT_DIR="/data/unencrypted/charch"
else
	CHROOT_DIR="$HOME/charch"
fi

# Path to rootfs tarball
ROOTFS_TAR="$CHROOT_DIR/rootfs.tar"

# Default command to execute on chroot enter
COMMAND="/usr/bin/env su -l"

usage() {
	echo -n "Usage: `basename $0` [OPTIONS] [NAME]

Options:
  -d DIRECTORY		Specify a chroot container directory (default: $CHROOT_DIR)
  -u URL		Specify a URL to fetch a rootfs tarball from
  -t TARBALL		Specify a path to fetch a rootfs tarball from (default: $ROOTFS_TAR)
  -c COMMAND		Command to execute inside the rootfs instance (default: $COMMAND)
  -n			Create a new rootfs instance
  -i			Create fresh mounts instead of recursive host binds
  -k			Keep host mounts after exiting the chroot
  -h			Show usage
"
}

while getopts ":d:u:t:c:nikh" opt; do
	case $opt in
		d)
			CHROOT_DIR="$OPTARG"
			;;
		u)
			ROOTFS_URL="$OPTARG"
			;;
		t)
			ROOTFS_TAR="$OPTARG"

			[[ ! -f "$ROOTFS_TAR" ]] && err "No rootfs tarball at $ROOTFS_TAR. Exiting."
			;;
		c)
			COMMAND="$OPTARG"
			;;
		n)
			CREATE=1
			;;
		i)
			ISOLATED=1
			;;
		k)
			KEEP_MOUNTS=1
			;;
		h)
			usage
			exit 0
			;;
		*)
			usage
			exit 1
			;;
	esac
done
shift $((OPTIND-1))

# The name of the current rootfs instance
if [[ ! -z "$1" ]]
then
	ROOTFS="$1"
	[[ "$ROOTFS" == *[/.]* ]] && err "Rootfs name contains illegal characters. Exiting."
else
	ROOTFS="rootfs"
fi

# Path to root of rootfs instance
ROOTFS_DIR="$CHROOT_DIR/$ROOTFS"

# Environmental variables for the chroot
ENV=(
	HOME="/root"
	TERM="xterm-256color"
)

fetch_rootfs() {
	[[ -z "$ROOTFS_URL" ]] && err "No rootfs tarball URL specified. Exiting."

	curl -# -L -o "$ROOTFS_TAR" "$ROOTFS_URL"

	[[ $? -ne 0 ]] && err "Failed to fetch rootfs tarball. Exiting."
}

setup_rootfs() {
	mkdir -p "$ROOTFS_DIR"
	tar xf "$ROOTFS_TAR" -C "$ROOTFS_DIR" &> /dev/null

	[[ $? -ne 0 ]] && err "Failed to extract rootfs tarball. Exiting."

	# Check for nested rootfs directory
	if [[ `ls "$ROOTFS_DIR" | wc -w` -eq 1 ]]
	then
		local dirname=`ls "$ROOTFS_DIR"`
		find "$ROOTFS_DIR/$dirname" -maxdepth 1 -mindepth 1 -exec mv {} "$ROOTFS_DIR" \;
		rm -rf "$ROOTFS_DIR/$dirname"
	fi
}

safe_mount() {
	# Create the mount point if it is missing
	[[ ! -d "$ROOTFS_DIR$2" ]] && mkdir -p "$ROOTFS_DIR$2"

	# Bind if it is not already mounted
	! mountpoint -q "$ROOTFS_DIR$2" &> /dev/null && mount -t "$1" "$1" "$ROOTFS_DIR$2"
}

safe_bind() {
	# Ensure the bind exists on the host
	[[ ! -d "$1" ]] && return 0

	# Create the mount point if it is missing
	[[ ! -d "$ROOTFS_DIR$1" ]] && mkdir -p "$ROOTFS_DIR$1"

	# Bind if it exists and it is not already mounted
	! mountpoint -q "$ROOTFS_DIR$1" &> /dev/null && mount --bind "$1" "$ROOTFS_DIR$1"
}

safe_rbind() {
	safe_bind "$1"
	for path in `mount | awk '{print $3}' | grep "^$1/"`
	do
		safe_bind "$path"
	done
}

find_mountpoint() {
        local path=`readlink -f "$1"`
        until mountpoint -q "$path" &>/dev/null
        do
                path=${path%/*}
                path=${path:-/}

		# Break if we reach the end of the filesystem
		[[ "$path" == "/" ]] && ! mountpoint -q "/" &> /dev/null && break
        done
        echo "$path"
}

setup_mounts() {
	if [[ "$ISOLATED" -eq 1 ]]
	then
		safe_mount tmpfs /dev
		safe_mount sysfs /sys
		safe_mount proc /proc
	else
		safe_rbind /dev
		safe_rbind /sys
		safe_rbind /proc
	fi

	safe_mount tmpfs /tmp

	# Remount data partition with suid to allow sudo to function
	local root_mount=`find_mountpoint "$CHROOT_DIR"`
	mountpoint -q "$root_mount" &> /dev/null && mount -o remount,suid,exec "$root_mount"
}

_chroot() {
	env -i "${ENV[@]}" chroot "$ROOTFS_DIR" $@
}

post_install() {
	# Add dns since userspace dns is volatile
	rm "$ROOTFS_DIR/etc/resolv.conf"
	echo "nameserver 1.1.1.1" > "$ROOTFS_DIR/etc/resolv.conf"
	echo "nameserver 1.0.0.1" >> "$ROOTFS_DIR/etc/resolv.conf"
}

# Create a new rootfs instance
if [[ "$CREATE" -eq 1 ]]
then
	[[ -d "$ROOTFS_DIR" ]] && err "Rootfs instance already exists at $ROOTFS_DIR. Exiting."

	[[ ! -f "$ROOTFS_TAR" ]] && [[ -z "$ROOTFS_URL" ]] && err "No tarball URL of path specified. Exiting."

	# Create initial chroot home
	[[ ! -d "$CHROOT_DIR" ]] && mkdir -p "$CHROOT_DIR"

	# Only fetch a new rootfs URL if:
	# 1) A rootfs tarball doesn't already exist, or
	# 2) User specified a URL to use
	[[ ! -f "$ROOTFS_TAR" ]] || [[ ! -z "$ROOTFS_URL" ]] && fetch_rootfs

	# Extract tarball
	setup_rootfs

	# Mount host binds
	setup_mounts

	# Fix common chroot issues and do post-install config
	post_install &> /dev/null
else
	[[ ! -d "$ROOTFS_DIR" ]] && err "No rootfs instance at $ROOTFS_DIR. Exiting."

	# Mount host binds
	setup_mounts
fi

# Enter chroot environment
_chroot "$COMMAND"

# Try to unmount rootfs mounts
[[ "$KEEP_MOUNTS" -eq 0 ]] && unarch -d "$CHROOT_DIR" "$ROOTFS"

exit 0
