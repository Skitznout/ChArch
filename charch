#!/bin/bash
# Written by Draco (tytydraco) @ GitHub

err() {
	echo -e "\e[91m[!] $@\e[39m"
	exit 1
}

# Path containing rootfs tarball and all rootfs instances
if [[ -d "/home" ]]
then
	CHROOT_DIR="/home/chroot"
else
	CHROOT_DIR="/data/local/chroot"
fi

# Default command to execute on chroot enter
COMMAND="su -l"

usage() {
	echo -n "Usage: `basename $0` [OPTIONS] [NAME]

Options:
  -d DIRECTORY		Specify a chroot container directory (default: $CHROOT_DIR)
  -u URL		Specify a URL to fetch a rootfs tarball from
  -c COMMAND		Command to execute inside the rootfs instance (default: $COMMAND)
  -n			Create a new rootfs instance
  -f			Force a tarball refetch even if it already exists
  -i			Create fresh mounts instead of recursive host binds
  -k			Keep host mounts after exiting the chroot
  -h			Show usage
"
}

while getopts ":d:u:c:nfikh" opt; do
	case $opt in
		d)
			CHROOT_DIR="$OPTARG"
			;;
		u)
			ROOTFS_URL="$OPTARG"
			FORCE_FETCH=1
			;;
		c)
			COMMAND="$OPTARG"
			;;
		n)
			CREATE=1
			;;
		f)
			FORCE_FETCH=1
			;;
		i)
			ISOLATED=1
			;;
		k)
			KEEP_MOUNTS=1
			;;
		h)
			usage
			exit 0
			;;
		*)
			usage
			exit 1
			;;
	esac
done
shift $((OPTIND-1))

# The name of the current rootfs instance
if [[ ! -z "$1" ]]
then
	ROOTFS="$1"
	[[ "$ROOTFS" == *[/.]* ]] && err "Rootfs name contains illegal characters. Exiting."
else
	ROOTFS="rootfs"
fi

# Path to root of rootfs instance
ROOTFS_DIR="$CHROOT_DIR/$ROOTFS"

# Add busybox components from Magisk
[[ -d "/sbin/.magisk/busybox" ]] && [[ "$PATH" != *"/sbin/.magisk/busybox"* ]] &&
	export PATH="$PATH:/sbin/.magisk/busybox"

# Environmental variables for the chroot
ENV=(
	HOME="/root"
	TERM="xterm-256color"
)

# Check for required dependencies
for dep in chroot curl env find id mkdir mount mountpoint readlink rm sed tar unarch wc
do
	! command -v "$dep" &> /dev/null && err "Unable to locate dependency $dep. Exiting."
done

# Check for root permissions
[[ `id -u` -ne 0 ]] && err "No root permissions. Exiting."

fetch_rootfs() {
	if [[ ! -f "$CHROOT_DIR/rootfs.tar.gz" ]] || [[ "$FORCE_FETCH" -eq 1 ]]
	then
		[[ -z "$ROOTFS_URL" ]] && err "No rootfs tarball URL specified. Exiting."

		curl -# -L -o "$CHROOT_DIR/rootfs.tar.gz" "$ROOTFS_URL"

		[[ $? -ne 0 ]] && err "Failed to fetch rootfs tarball. Exiting."
	fi
}

setup_rootfs() {
	mkdir -p "$ROOTFS_DIR"
	tar xf "$CHROOT_DIR/rootfs.tar.gz" -C "$ROOTFS_DIR" &> /dev/null

	[[ $? -ne 0 ]] && err "Failed to extract rootfs tarball. Exiting."

	# Check for nested rootfs directory
	local dircount=`ls "$ROOTFS_DIR" | wc -w`
	if [[ "$dircount" -eq 1 ]]
	then
		local dirname=`ls "$ROOTFS_DIR" | head -n 1`
		find "$ROOTFS_DIR/$dirname" -maxdepth 1 -mindepth 1 -exec mv {} "$ROOTFS_DIR" \;
		rm -rf "$ROOTFS_DIR/$dirname"
	fi
}

safe_mount() {
	# Create the mount point if it is missing
	[[ ! -d "$ROOTFS_DIR/$2" ]] && mkdir -p "$ROOTFS_DIR/$2"

	# Bind if it is not already mounted
	! mountpoint -q "$ROOTFS_DIR/$2" &> /dev/null && mount -t "$1" "$1" "$ROOTFS_DIR/$2"
}

safe_bind() {
	# Ensure the bind exists on the host
	[[ ! -d "/$1" ]] && return 0

	# Create the mount point if it is missing
	[[ ! -d "$ROOTFS_DIR/$1" ]] && mkdir -p "$ROOTFS_DIR/$1"

	# Bind if it exists and it is not already mounted
	! mountpoint -q "$ROOTFS_DIR/$1" &> /dev/null && mount --bind "/$1" "$ROOTFS_DIR/$1"
}

safe_rbind() {
	safe_bind "$1"
	for path in `mount | awk '{print $3}' | grep "^\/$1/"`
	do
		safe_bind "$path"
	done
}

find_mountpoint() {
        local path=`readlink -f "$1"`
        until mountpoint -q "$path" &>/dev/null
        do
                path=${path%/*}
                path=${path:-/}

		# Break if we reach the end of the filesystem
		[[ "$path" == "/" ]] && ! mountpoint -q "/" &> /dev/null && break
        done
        echo "$path"
}

setup_mounts() {
	if [[ "$ISOLATED" -eq 1 ]]
	then
		safe_mount tmpfs dev
		safe_mount sysfs sys
		safe_mount proc proc
		safe_mount tmpfs run
	else
		safe_rbind dev
		safe_rbind sys
		safe_rbind proc
		safe_rbind run
	fi

	safe_mount tmpfs tmp

	# Remount data partition with suid to allow sudo to function
	local root_mount=`find_mountpoint "$CHROOT_DIR"`
	mountpoint -q "$root_mount" &> /dev/null && mount -o remount,suid,exec "$root_mount"
}

_chroot() {
	env -i "${ENV[@]}" chroot "$ROOTFS_DIR" $@
}

post_install() {
	# Add dns since userspace dns is volatile
	rm "$ROOTFS_DIR/etc/resolv.conf"
	echo "nameserver 1.1.1.1" > "$ROOTFS_DIR/etc/resolv.conf"
	echo "nameserver 1.0.0.1" >> "$ROOTFS_DIR/etc/resolv.conf"

	# Pacman
	if [[ -f "$ROOTFS_DIR/etc/pacman.conf" ]]
	then
		# Fix broken space check for pacman in chroot
		sed -i "s/^CheckSpace$/#CheckSpace/" "$ROOTFS_DIR/etc/pacman.conf"

		# Update and populate pacman keys
		_chroot pacman-key --init
		_chroot pacman-key --populate

		# Remove built-in linux kernel and firmware
		_chroot pacman -Rcn --noconfirm linux-firmware
	fi

	# Apt
	if [[ -d "$ROOTFS_DIR/etc/apt/" ]]
	then
		# Remove built-in linux kernel and firmware
		_chroot apt-get -y remove --auto-remove linux-firmware
		_chroot apt-get -y remove --auto-remove "^linux-image.*"
	fi
}

# Create a new rootfs instance
if [[ "$CREATE" -eq 1 ]]
then
	[[ -d "$ROOTFS_DIR" ]] && err "Rootfs instance already exists at $ROOTFS_DIR. Exiting."

	# Create initial chroot home
	[[ ! -d "$CHROOT_DIR" ]] && mkdir -p "$CHROOT_DIR"

	# Fetch latest rootfs tarball for architecture
	fetch_rootfs

	# Extract tarball
	setup_rootfs

	# Mount host binds
	setup_mounts

	# Fix common chroot issues and do post-install config
	post_install &> /dev/null
else
	[[ ! -d "$ROOTFS_DIR" ]] && err "No rootfs instance at $ROOTFS_DIR. Exiting."

	# Mount host binds
	setup_mounts
fi

# Enter chroot environment
_chroot "$COMMAND"

# Try to unmount rootfs mounts
[[ "$KEEP_MOUNTS" -eq 0 ]] && unarch -d "$CHROOT_DIR" "$ROOTFS"
